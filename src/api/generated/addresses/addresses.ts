/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * ShopDjango API
 * API for ShopDjango project
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  Address,
  AddressCreate,
  AddressUpdate,
  AddressesListParams,
  PaginatedAddressListList,
  PatchedAddress,
  PatchedAddressUpdate
} from '.././schemas';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * ViewSet for managing user addresses.
 */
export const addressesList = (
    params?: AddressesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedAddressListList>> => {
    
    
    return axios.default.get(
      `/api/addresses/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getAddressesListQueryKey = (params?: AddressesListParams,) => {
    return [`/api/addresses/`, ...(params ? [params]: [])] as const;
    }

    
export const getAddressesListQueryOptions = <TData = Awaited<ReturnType<typeof addressesList>>, TError = AxiosError<unknown>>(params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesList>>> = ({ signal }) => addressesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesListQueryResult = NonNullable<Awaited<ReturnType<typeof addressesList>>>
export type AddressesListQueryError = AxiosError<unknown>


export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = AxiosError<unknown>>(
 params: undefined |  AddressesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesList>>,
          TError,
          Awaited<ReturnType<typeof addressesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = AxiosError<unknown>>(
 params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesList>>,
          TError,
          Awaited<ReturnType<typeof addressesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = AxiosError<unknown>>(
 params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = AxiosError<unknown>>(
 params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing user addresses.
 */
export const addressesCreate = (
    addressCreate: AddressCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AddressCreate>> => {
    
    
    return axios.default.post(
      `/api/addresses/`,
      addressCreate,options
    );
  }



export const getAddressesCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesCreate>>, TError,{data: AddressCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addressesCreate>>, TError,{data: AddressCreate}, TContext> => {

const mutationKey = ['addressesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesCreate>>, {data: AddressCreate}> = (props) => {
          const {data} = props ?? {};

          return  addressesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesCreate>>>
    export type AddressesCreateMutationBody = AddressCreate
    export type AddressesCreateMutationError = AxiosError<unknown>

    export const useAddressesCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesCreate>>, TError,{data: AddressCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesCreate>>,
        TError,
        {data: AddressCreate},
        TContext
      > => {

      const mutationOptions = getAddressesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user addresses.
 */
export const addressesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.get(
      `/api/addresses/${id}/`,options
    );
  }


export const getAddressesRetrieveQueryKey = (id: number,) => {
    return [`/api/addresses/${id}/`] as const;
    }

    
export const getAddressesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesRetrieve>>> = ({ signal }) => addressesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesRetrieve>>>
export type AddressesRetrieveQueryError = AxiosError<unknown>


export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing user addresses.
 */
export const addressesUpdate = (
    id: number,
    addressUpdate: AddressUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AddressUpdate>> => {
    
    
    return axios.default.put(
      `/api/addresses/${id}/`,
      addressUpdate,options
    );
  }



export const getAddressesUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUpdate>>, TError,{id: number;data: AddressUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addressesUpdate>>, TError,{id: number;data: AddressUpdate}, TContext> => {

const mutationKey = ['addressesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesUpdate>>, {id: number;data: AddressUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  addressesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesUpdate>>>
    export type AddressesUpdateMutationBody = AddressUpdate
    export type AddressesUpdateMutationError = AxiosError<unknown>

    export const useAddressesUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUpdate>>, TError,{id: number;data: AddressUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesUpdate>>,
        TError,
        {id: number;data: AddressUpdate},
        TContext
      > => {

      const mutationOptions = getAddressesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user addresses.
 */
export const addressesPartialUpdate = (
    id: number,
    patchedAddressUpdate: PatchedAddressUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AddressUpdate>> => {
    
    
    return axios.default.patch(
      `/api/addresses/${id}/`,
      patchedAddressUpdate,options
    );
  }



export const getAddressesPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesPartialUpdate>>, TError,{id: number;data: PatchedAddressUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addressesPartialUpdate>>, TError,{id: number;data: PatchedAddressUpdate}, TContext> => {

const mutationKey = ['addressesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesPartialUpdate>>, {id: number;data: PatchedAddressUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  addressesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesPartialUpdate>>>
    export type AddressesPartialUpdateMutationBody = PatchedAddressUpdate
    export type AddressesPartialUpdateMutationError = AxiosError<unknown>

    export const useAddressesPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesPartialUpdate>>, TError,{id: number;data: PatchedAddressUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesPartialUpdate>>,
        TError,
        {id: number;data: PatchedAddressUpdate},
        TContext
      > => {

      const mutationOptions = getAddressesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user addresses.
 */
export const addressesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/addresses/${id}/`,options
    );
  }



export const getAddressesDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addressesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['addressesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  addressesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof addressesDestroy>>>
    
    export type AddressesDestroyMutationError = AxiosError<unknown>

    export const useAddressesDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getAddressesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Set this address as default for its type.
 */
export const addressesSetDefaultPartialUpdate = (
    id: number,
    patchedAddress: NonReadonly<PatchedAddress>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.patch(
      `/api/addresses/${id}/set_default/`,
      patchedAddress,options
    );
  }



export const getAddressesSetDefaultPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAddress>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAddress>}, TContext> => {

const mutationKey = ['addressesSetDefaultPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, {id: number;data: NonReadonly<PatchedAddress>}> = (props) => {
          const {id,data} = props ?? {};

          return  addressesSetDefaultPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesSetDefaultPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>>
    export type AddressesSetDefaultPartialUpdateMutationBody = NonReadonly<PatchedAddress>
    export type AddressesSetDefaultPartialUpdateMutationError = AxiosError<unknown>

    export const useAddressesSetDefaultPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAddress>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedAddress>},
        TContext
      > => {

      const mutationOptions = getAddressesSetDefaultPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get all billing addresses for the user.
 */
export const addressesBillingRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.get(
      `/api/addresses/billing/`,options
    );
  }


export const getAddressesBillingRetrieveQueryKey = () => {
    return [`/api/addresses/billing/`] as const;
    }

    
export const getAddressesBillingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesBillingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesBillingRetrieve>>> = ({ signal }) => addressesBillingRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesBillingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesBillingRetrieve>>>
export type AddressesBillingRetrieveQueryError = AxiosError<unknown>


export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesBillingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesBillingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesBillingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get default billing address for the user.
 */
export const addressesDefaultBillingRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.get(
      `/api/addresses/default_billing/`,options
    );
  }


export const getAddressesDefaultBillingRetrieveQueryKey = () => {
    return [`/api/addresses/default_billing/`] as const;
    }

    
export const getAddressesDefaultBillingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesDefaultBillingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>> = ({ signal }) => addressesDefaultBillingRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesDefaultBillingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>>
export type AddressesDefaultBillingRetrieveQueryError = AxiosError<unknown>


export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesDefaultBillingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get default shipping address for the user.
 */
export const addressesDefaultShippingRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.get(
      `/api/addresses/default_shipping/`,options
    );
  }


export const getAddressesDefaultShippingRetrieveQueryKey = () => {
    return [`/api/addresses/default_shipping/`] as const;
    }

    
export const getAddressesDefaultShippingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesDefaultShippingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>> = ({ signal }) => addressesDefaultShippingRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesDefaultShippingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>>
export type AddressesDefaultShippingRetrieveQueryError = AxiosError<unknown>


export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesDefaultShippingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get all shipping addresses for the user.
 */
export const addressesShippingRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.get(
      `/api/addresses/shipping/`,options
    );
  }


export const getAddressesShippingRetrieveQueryKey = () => {
    return [`/api/addresses/shipping/`] as const;
    }

    
export const getAddressesShippingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesShippingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesShippingRetrieve>>> = ({ signal }) => addressesShippingRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesShippingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesShippingRetrieve>>>
export type AddressesShippingRetrieveQueryError = AxiosError<unknown>


export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesShippingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesShippingRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesShippingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get summary of user's addresses.
 */
export const addressesSummaryRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.get(
      `/api/addresses/summary/`,options
    );
  }


export const getAddressesSummaryRetrieveQueryKey = () => {
    return [`/api/addresses/summary/`] as const;
    }

    
export const getAddressesSummaryRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesSummaryRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesSummaryRetrieve>>> = ({ signal }) => addressesSummaryRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesSummaryRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesSummaryRetrieve>>>
export type AddressesSummaryRetrieveQueryError = AxiosError<unknown>


export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesSummaryRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Remove default status for addresses of specified type.
 */
export const addressesUnsetDefaultPartialUpdate = (
    patchedAddress: NonReadonly<PatchedAddress>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Address>> => {
    
    
    return axios.default.patch(
      `/api/addresses/unset_default/`,
      patchedAddress,options
    );
  }



export const getAddressesUnsetDefaultPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, TError,{data: NonReadonly<PatchedAddress>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, TError,{data: NonReadonly<PatchedAddress>}, TContext> => {

const mutationKey = ['addressesUnsetDefaultPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, {data: NonReadonly<PatchedAddress>}> = (props) => {
          const {data} = props ?? {};

          return  addressesUnsetDefaultPartialUpdate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesUnsetDefaultPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>>
    export type AddressesUnsetDefaultPartialUpdateMutationBody = NonReadonly<PatchedAddress>
    export type AddressesUnsetDefaultPartialUpdateMutationError = AxiosError<unknown>

    export const useAddressesUnsetDefaultPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, TError,{data: NonReadonly<PatchedAddress>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>,
        TError,
        {data: NonReadonly<PatchedAddress>},
        TContext
      > => {

      const mutationOptions = getAddressesUnsetDefaultPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
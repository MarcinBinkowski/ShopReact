/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * ShopDjango API
 * API for ShopDjango project
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Address,
  AddressCreate,
  AddressUpdate,
  AddressesListParams,
  PaginatedAddressListList,
  PatchedAddress,
  PatchedAddressUpdate
} from '.././schemas';

import { shopInstance } from '../../../shop-mutator';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * ViewSet for managing user addresses.
 */
export const addressesList = (
    params?: AddressesListParams,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<PaginatedAddressListList>(
      {url: `/api/addresses/`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getAddressesListQueryKey = (params?: AddressesListParams,) => {
    return [`/api/addresses/`, ...(params ? [params]: [])] as const;
    }

    
export const getAddressesListQueryOptions = <TData = Awaited<ReturnType<typeof addressesList>>, TError = unknown>(params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesList>>> = ({ signal }) => addressesList(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesListQueryResult = NonNullable<Awaited<ReturnType<typeof addressesList>>>
export type AddressesListQueryError = unknown


export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = unknown>(
 params: undefined |  AddressesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesList>>,
          TError,
          Awaited<ReturnType<typeof addressesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = unknown>(
 params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesList>>,
          TError,
          Awaited<ReturnType<typeof addressesList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = unknown>(
 params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesList<TData = Awaited<ReturnType<typeof addressesList>>, TError = unknown>(
 params?: AddressesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing user addresses.
 */
export const addressesCreate = (
    addressCreate: AddressCreate,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<AddressCreate>(
      {url: `/api/addresses/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addressCreate, signal
    },
      );
    }
  


export const getAddressesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesCreate>>, TError,{data: AddressCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addressesCreate>>, TError,{data: AddressCreate}, TContext> => {

const mutationKey = ['addressesCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesCreate>>, {data: AddressCreate}> = (props) => {
          const {data} = props ?? {};

          return  addressesCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesCreate>>>
    export type AddressesCreateMutationBody = AddressCreate
    export type AddressesCreateMutationError = unknown

    export const useAddressesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesCreate>>, TError,{data: AddressCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesCreate>>,
        TError,
        {data: AddressCreate},
        TContext
      > => {

      const mutationOptions = getAddressesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user addresses.
 */
export const addressesRetrieve = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/${id}/`, method: 'GET', signal
    },
      );
    }
  

export const getAddressesRetrieveQueryKey = (id: number,) => {
    return [`/api/addresses/${id}/`] as const;
    }

    
export const getAddressesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesRetrieve>>> = ({ signal }) => addressesRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesRetrieve>>>
export type AddressesRetrieveQueryError = unknown


export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesRetrieve<TData = Awaited<ReturnType<typeof addressesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * ViewSet for managing user addresses.
 */
export const addressesUpdate = (
    id: number,
    addressUpdate: AddressUpdate,
 ) => {
      
      
      return shopInstance<AddressUpdate>(
      {url: `/api/addresses/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: addressUpdate
    },
      );
    }
  


export const getAddressesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUpdate>>, TError,{id: number;data: AddressUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addressesUpdate>>, TError,{id: number;data: AddressUpdate}, TContext> => {

const mutationKey = ['addressesUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesUpdate>>, {id: number;data: AddressUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  addressesUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesUpdate>>>
    export type AddressesUpdateMutationBody = AddressUpdate
    export type AddressesUpdateMutationError = unknown

    export const useAddressesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUpdate>>, TError,{id: number;data: AddressUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesUpdate>>,
        TError,
        {id: number;data: AddressUpdate},
        TContext
      > => {

      const mutationOptions = getAddressesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user addresses.
 */
export const addressesPartialUpdate = (
    id: number,
    patchedAddressUpdate: PatchedAddressUpdate,
 ) => {
      
      
      return shopInstance<AddressUpdate>(
      {url: `/api/addresses/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAddressUpdate
    },
      );
    }
  


export const getAddressesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesPartialUpdate>>, TError,{id: number;data: PatchedAddressUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addressesPartialUpdate>>, TError,{id: number;data: PatchedAddressUpdate}, TContext> => {

const mutationKey = ['addressesPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesPartialUpdate>>, {id: number;data: PatchedAddressUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  addressesPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesPartialUpdate>>>
    export type AddressesPartialUpdateMutationBody = PatchedAddressUpdate
    export type AddressesPartialUpdateMutationError = unknown

    export const useAddressesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesPartialUpdate>>, TError,{id: number;data: PatchedAddressUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesPartialUpdate>>,
        TError,
        {id: number;data: PatchedAddressUpdate},
        TContext
      > => {

      const mutationOptions = getAddressesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * ViewSet for managing user addresses.
 */
export const addressesDestroy = (
    id: number,
 ) => {
      
      
      return shopInstance<void>(
      {url: `/api/addresses/${id}/`, method: 'DELETE'
    },
      );
    }
  


export const getAddressesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesDestroy>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addressesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['addressesDestroy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  addressesDestroy(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof addressesDestroy>>>
    
    export type AddressesDestroyMutationError = unknown

    export const useAddressesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesDestroy>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getAddressesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Set this address as default for its type.
 */
export const addressesSetDefaultPartialUpdate = (
    id: number,
    patchedAddress: NonReadonly<PatchedAddress>,
 ) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/${id}/set_default/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAddress
    },
      );
    }
  


export const getAddressesSetDefaultPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAddress>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAddress>}, TContext> => {

const mutationKey = ['addressesSetDefaultPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, {id: number;data: NonReadonly<PatchedAddress>}> = (props) => {
          const {id,data} = props ?? {};

          return  addressesSetDefaultPartialUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesSetDefaultPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>>
    export type AddressesSetDefaultPartialUpdateMutationBody = NonReadonly<PatchedAddress>
    export type AddressesSetDefaultPartialUpdateMutationError = unknown

    export const useAddressesSetDefaultPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAddress>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesSetDefaultPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedAddress>},
        TContext
      > => {

      const mutationOptions = getAddressesSetDefaultPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Get all billing addresses for the user.
 */
export const addressesBillingRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/billing/`, method: 'GET', signal
    },
      );
    }
  

export const getAddressesBillingRetrieveQueryKey = () => {
    return [`/api/addresses/billing/`] as const;
    }

    
export const getAddressesBillingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesBillingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesBillingRetrieve>>> = ({ signal }) => addressesBillingRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesBillingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesBillingRetrieve>>>
export type AddressesBillingRetrieveQueryError = unknown


export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesBillingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesBillingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesBillingRetrieve<TData = Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesBillingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesBillingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get default billing address for the user.
 */
export const addressesDefaultBillingRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/default_billing/`, method: 'GET', signal
    },
      );
    }
  

export const getAddressesDefaultBillingRetrieveQueryKey = () => {
    return [`/api/addresses/default_billing/`] as const;
    }

    
export const getAddressesDefaultBillingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesDefaultBillingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>> = ({ signal }) => addressesDefaultBillingRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesDefaultBillingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>>
export type AddressesDefaultBillingRetrieveQueryError = unknown


export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesDefaultBillingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultBillingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesDefaultBillingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get default shipping address for the user.
 */
export const addressesDefaultShippingRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/default_shipping/`, method: 'GET', signal
    },
      );
    }
  

export const getAddressesDefaultShippingRetrieveQueryKey = () => {
    return [`/api/addresses/default_shipping/`] as const;
    }

    
export const getAddressesDefaultShippingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesDefaultShippingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>> = ({ signal }) => addressesDefaultShippingRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesDefaultShippingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>>
export type AddressesDefaultShippingRetrieveQueryError = unknown


export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesDefaultShippingRetrieve<TData = Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesDefaultShippingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesDefaultShippingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get all shipping addresses for the user.
 */
export const addressesShippingRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/shipping/`, method: 'GET', signal
    },
      );
    }
  

export const getAddressesShippingRetrieveQueryKey = () => {
    return [`/api/addresses/shipping/`] as const;
    }

    
export const getAddressesShippingRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesShippingRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesShippingRetrieve>>> = ({ signal }) => addressesShippingRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesShippingRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesShippingRetrieve>>>
export type AddressesShippingRetrieveQueryError = unknown


export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesShippingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesShippingRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesShippingRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesShippingRetrieve<TData = Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesShippingRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesShippingRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get summary of user's addresses.
 */
export const addressesSummaryRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/summary/`, method: 'GET', signal
    },
      );
    }
  

export const getAddressesSummaryRetrieveQueryKey = () => {
    return [`/api/addresses/summary/`] as const;
    }

    
export const getAddressesSummaryRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressesSummaryRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressesSummaryRetrieve>>> = ({ signal }) => addressesSummaryRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressesSummaryRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof addressesSummaryRetrieve>>>
export type AddressesSummaryRetrieveQueryError = unknown


export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof addressesSummaryRetrieve>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAddressesSummaryRetrieve<TData = Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressesSummaryRetrieve>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressesSummaryRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Remove default status for addresses of specified type.
 */
export const addressesUnsetDefaultPartialUpdate = (
    patchedAddress: NonReadonly<PatchedAddress>,
 ) => {
      
      
      return shopInstance<Address>(
      {url: `/api/addresses/unset_default/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAddress
    },
      );
    }
  


export const getAddressesUnsetDefaultPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, TError,{data: NonReadonly<PatchedAddress>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, TError,{data: NonReadonly<PatchedAddress>}, TContext> => {

const mutationKey = ['addressesUnsetDefaultPartialUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, {data: NonReadonly<PatchedAddress>}> = (props) => {
          const {data} = props ?? {};

          return  addressesUnsetDefaultPartialUpdate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressesUnsetDefaultPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>>
    export type AddressesUnsetDefaultPartialUpdateMutationBody = NonReadonly<PatchedAddress>
    export type AddressesUnsetDefaultPartialUpdateMutationError = unknown

    export const useAddressesUnsetDefaultPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>, TError,{data: NonReadonly<PatchedAddress>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressesUnsetDefaultPartialUpdate>>,
        TError,
        {data: NonReadonly<PatchedAddress>},
        TContext
      > => {

      const mutationOptions = getAddressesUnsetDefaultPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    